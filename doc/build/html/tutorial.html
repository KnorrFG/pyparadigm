
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>A tutorial &#8212; PyParadigm 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="Welcome to PyParadigm" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="a-tutorial">
<h1>A tutorial<a class="headerlink" href="#a-tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>As most python libraries, PyParadigm can be installed via pip:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">pyparadigm</span>
</pre></div>
</div>
<p>And thats it.</p>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>PyParadigm is split into 4 modules:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt><a class="reference internal" href="surfacecomposition.html"><span class="doc">The Surface Composition Module</span></a> which allows to create</dt><dd><p>pygame.Surfaces , which is the class representing images, in a
declarative way.</p>
</dd>
</dl>
</li>
<li><p><a class="reference internal" href="eventlistener.html"><span class="doc">The Event Listener Module</span></a> which allows to react to user input</p></li>
<li><p><a class="reference internal" href="misc.html"><span class="doc">The Misc-Module</span></a> which just contains a few utility functions</p></li>
<li><p><a class="reference internal" href="extras.html"><span class="doc">Extras</span></a> which contains functions to render numpy arrays</p></li>
</ul>
</dd>
</dl>
<p>Althout PyParadigm is organized into multiple modules, everything can be
imported from <cite>pyparadigm</cite> directly. The contents of <a class="reference internal" href="extras.html"><span class="doc">Extras</span></a> is only
imported if matplotlib and numpy are installed</p>
</div>
<div class="section" id="creating-a-window">
<span id="id1"></span><h2>Creating a Window<a class="headerlink" href="#creating-a-window" title="Permalink to this headline">¶</a></h2>
<p>In the simplest option to create a window is nothing but a call to the
<code class="xref py py-func docutils literal notranslate"><span class="pre">init()</span></code> function of the <a class="reference internal" href="misc.html"><span class="doc">Misc-Module</span></a>, which only takes
one parameter: a 2-tuple with the prefered resolution. E.g. <code class="docutils literal notranslate"><span class="pre">init((800,</span>
<span class="pre">600))</span></code>. However, most of the time, this is not exactly what you want.
Usually you want to create a full-screen or borderless window (which looks like
fullscreen, if it has the size of the screen, but behaves a little different).
For these scenarios, you can use the pygame_flags argument.
One of the things that <code class="xref py py-func docutils literal notranslate"><span class="pre">init()</span></code> does is calling
<a class="reference external" href="https://www.pygame.org/docs/ref/display.html#pygame.display.set_mode">pygame.display.set_mode()</a>, which
is the pygame function that creates the window, and the flags argument is passed
through. Here, a short list of flags you will care about the most:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pygame.FULLSCREEN</span></code> which will create a full-screen window.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">pygame.NOFRAME</span></code> which creates a window without window-frame. This looks</dt><dd><p>like fullscreen if the created window has the same resolution as the desktop
and is placed at (0, 0).</p>
</dd>
</dl>
</li>
</ul>
<p>By default, the CPU will be used to render the images. This should suffice for
most paradigms. If, however, your paradigm is computationally very intensive and
requires a GPU you could use pygame.HWSURFACE, usually in combination with
pygame.DOUBLEBUF and pygame.FULLSCREEN, you can combine multiple flags with the
<code class="docutils literal notranslate"><span class="pre">|</span></code> operator. E.g:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">init</span><span class="p">((</span><span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">),</span> <span class="n">pygame</span><span class="o">.</span><span class="n">FULLSCREEN</span> <span class="o">|</span> <span class="n">pygame</span><span class="o">.</span><span class="n">HWSURFACE</span> <span class="o">|</span> <span class="n">pygame</span><span class="o">.</span><span class="n">DOUBLEBUF</span><span class="p">)</span>
</pre></div>
</div>
<p>A warning: Creating a hardware accelerated window in other systems than Windows
can be problematic.
Now we can worry about how to fill this screen.</p>
</div>
<div class="section" id="creating-surfaces">
<span id="id2"></span><h2>Creating Surfaces<a class="headerlink" href="#creating-surfaces" title="Permalink to this headline">¶</a></h2>
<p>An important concept here is to avoid worrying about absolute positions. Using
<code class="xref py py-func docutils literal notranslate"><span class="pre">compose()</span></code>, an image-structure can be described as a tree of elements.
E.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">compose</span><span class="p">(</span><span class="n">target_surface</span><span class="p">)(</span>
    <span class="n">LinLayout</span><span class="p">(</span><span class="s2">&quot;h&quot;</span><span class="p">)(</span>
        <span class="n">Circle</span><span class="p">(</span><span class="mh">0xFF0000</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">Circle</span><span class="p">(</span><span class="mh">0x00FF00</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Here, the available space (which is the size of <code class="docutils literal notranslate"><span class="pre">target_surface</span></code>) is divided
horizontally (<code class="docutils literal notranslate"><span class="pre">&quot;h&quot;</span></code>) into 2 parts of equal size. Generally, the space is
equally divided between the children if not explicitly modified. Then, a red
circle will be drawn into the left area and a blue one in the right area. The
trees can get arbitrarily complex, and I recommend to take a look at the
<a class="reference internal" href="examples.html"><span class="doc">examples</span></a></p>
<p>Here is a list of the different elements that can be used within
<code class="xref py py-func docutils literal notranslate"><span class="pre">compose()</span></code></p>
<ul class="simple">
<li><dl class="simple">
<dt>Containers with multiple children:</dt><dd><ul>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">LinLayout</span></code> arranges items in a horizontal or vertical line</p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">GridLayout()</span></code> arranges items in a grid</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Overlay</span></code> draws its children on top of each other</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Wrappers, which take a single child:</dt><dd><ul>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Padding</span></code> creates a padding around its child</p></li>
<li><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">LLItem</span></code> is only usable within a <code class="xref py py-class docutils literal notranslate"><span class="pre">LinLayout</span></code> and defines</dt><dd><p>proportions of items within a <code class="xref py py-class docutils literal notranslate"><span class="pre">LinLayout</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">Surface</span></code> wraps pygame.Surfaces.</dt><dd><p>E.g. loaded stimuli from files or texts, which are also generated as
Surfaces. All pygame.Surfaces in a tree are wrapped in
<code class="xref py py-class docutils literal notranslate"><span class="pre">Surface</span></code> objects automatically. It can also be done manually
to change placement or scaling options.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">RectangleShaper</span></code> is closely related to <code class="xref py py-class docutils literal notranslate"><span class="pre">Padding</span></code>. It</dt><dd><p>will create horizontal or vertical padding to create a child-shape with a
desired aspect ratio.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">Fill</span></code> fills the assigned area with a given color before</dt><dd><p>rendering its child. Can also be used without child.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">Border</span></code> creates a border around its area. Can also be used</dt><dd><p>without child.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Primitives that don’t take any children:</dt><dd><ul>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Circle</span></code> draws a circle in the assigned area</p></li>
<li><p><code class="xref py py-func docutils literal notranslate"><span class="pre">Cross()</span></code> draws a cross within the assigned area</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Line</span></code> draws a line within the assigned area</p></li>
<li><dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">Text()</span></code> creates a pygame.Surface containing the passed text. The</dt><dd><p>text can be multi-line, left-/ or right-aligned or centered. It takes a
pygame.Font as additional argument.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Children are generally passed via the <code class="xref py py-func docutils literal notranslate"><span class="pre">__call__()</span></code> operator of the
object. E.g. <code class="docutils literal notranslate"><span class="pre">LinLayout(&quot;h&quot;)(child1,</span> <span class="pre">child2,</span> <span class="pre">child3)</span></code> Whenever something only
takes a single child, the child can be a container. This way, it is possible to
add multiple children whenever only one child is allowed. <code class="xref py py-func docutils literal notranslate"><span class="pre">compose()</span></code>
itself allows only one child, which gets the whole image as target area. But
since a lot of <code class="xref py py-func docutils literal notranslate"><span class="pre">compose()</span></code> calls would have a container as its child,
<code class="xref py py-func docutils literal notranslate"><span class="pre">compose()</span></code> allows a second argument, which can be any component that
takes at least one child (except for Surface). The above example could also be
written like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">compose</span><span class="p">(</span><span class="n">target_surface</span><span class="p">,</span> <span class="n">LinLayout</span><span class="p">(</span><span class="s2">&quot;h&quot;</span><span class="p">))(</span>
        <span class="n">Circle</span><span class="p">(</span><span class="mh">0xFF0000</span><span class="p">),</span>
        <span class="n">Circle</span><span class="p">(</span><span class="mh">0x00FF00</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The first argument to <code class="xref py py-func docutils literal notranslate"><span class="pre">compose()</span></code> can either be a pygame.Surface to
render on (like above) or a 2-tuple with width and height. In the second case, a
new pygame.Surface with the specified dimensions would be created. To get a desired
background color for the newly created surface the root component should be a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Fill</span></code> object.</p>
<p>The most common case though would be</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">compose</span><span class="p">(</span><span class="n">empty_surface</span><span class="p">(</span><span class="n">color</span><span class="p">),</span> <span class="n">LinLayout</span><span class="p">(</span><span class="s2">&quot;h&quot;</span><span class="p">))(</span>
        <span class="n">Circle</span><span class="p">(</span><span class="mh">0xFF0000</span><span class="p">),</span>
        <span class="n">Circle</span><span class="p">(</span><span class="mh">0x00FF00</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">empty_surface()</span></code> is part of the <a class="reference internal" href="misc.html"><span class="doc">Misc-Module</span></a> and will
create a new pygame.Surface which is automatically filled with the given color.
A size for the new surface can be specified as second argument. If the size
argument is omitted, the created pygame.Surface will automatically have the size of the
display.</p>
<p>To display saved images, use <code class="xref py py-func docutils literal notranslate"><span class="pre">pygame.image.load()</span></code> and just use the
loaded pygame.Surface in compose.</p>
<div class="section" id="creating-text">
<h3>Creating Text<a class="headerlink" href="#creating-text" title="Permalink to this headline">¶</a></h3>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">Text()</span></code> is not an object with a <code class="xref py py-meth docutils literal notranslate"><span class="pre">_draw()</span></code>-method but a function that returns
a pygame.Surface, which contains the text on a transparent background.
Since a pygame.Surface is automatically wrapped into a
<code class="xref py py-class docutils literal notranslate"><span class="pre">surface_composition.Surface</span></code> object, it can be used like any other object.
This means that it will be centered in the available space and scaled down if the
available space is smaller than the text, but not scaled up otherwise.
You can wrap it explicitly in a <code class="xref py py-class docutils literal notranslate"><span class="pre">surface_composition.Surface</span></code> to
change scaling and positioning behavior.</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">Text()</span></code> takes a pygame.Font as second argument, which can also be used to set the
size, and modifiers i.e. bold and italic.
Also Text supports multi-line texts which will be aligned according to the
align-parameter.
To load a font, the <code class="xref py py-func docutils literal notranslate"><span class="pre">Font()</span></code> function can be used. If called without
parameters, it will use the default system font with size=20 and without any modifiers, e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Text</span><span class="p">(</span><span class="s2">&quot;Hello</span><span class="se">\n</span><span class="s2">Wordl!&quot;</span><span class="p">,</span> <span class="n">Font</span><span class="p">())</span>
</pre></div>
</div>
<p>Usually most text within a paradigm uses the same font settings. Therefore, it’s
recommended to define a function with according parameters. e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">instruction_text</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">Text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Font</span><span class="p">(</span><span class="s2">&quot;arial&quot;</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="a-tip-for-performance">
<h3>A tip for performance<a class="headerlink" href="#a-tip-for-performance" title="Permalink to this headline">¶</a></h3>
<p>Commonly, a paradigm is composed of a hand full of screens, which are the
same except for the specific content. E.g in the
<a class="reference internal" href="examples.html#examples-itech"><span class="std std-ref">IteCh example</span></a>, there is a function <code class="docutils literal notranslate"><span class="pre">make_offer()</span></code> that will
create the offer screen and takes the details of the offer as arguments.
If such a function is called multiple times with the same
arguments, it is recommended to use
<a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.lru_cache">functools.lru_cache</a>
as annotator. In this way, the screen will only be computed once for every unique
parameter combination, and, after the first call, the result will be returned from
cache, which lowers computation time.</p>
<p>The reason this was not done in the <a class="reference internal" href="examples.html#examples-itech"><span class="std std-ref">IteCh example</span></a> was
that <code class="docutils literal notranslate"><span class="pre">make_offer()</span></code> was never called twice for a unique parameter combination.</p>
</div>
<div class="section" id="using-numpy-arrays-as-images">
<h3>Using numpy arrays as images<a class="headerlink" href="#using-numpy-arrays-as-images" title="Permalink to this headline">¶</a></h3>
<p>It is possible to use numpy arrays as input for images. The extras module
contains the <code class="xref py py-func docutils literal notranslate"><span class="pre">mat_to_surface()</span></code> function, which will return a
pygame.Surface which can then be used within compose. It expects a 2D array of
rgb values, and applies a transformer function to create a gray-value image.
Alternatively <code class="xref py py-func docutils literal notranslate"><span class="pre">apply_color_map()</span></code> can be used to get a colored surface
according to a matplotlib color map.</p>
<p>To generate a pygame.Surface from a 3D array where the third axis contains rgb
values you can use <code class="xref py py-func docutils literal notranslate"><span class="pre">pygame.pixelcopy.make_surface()</span></code>. Be aware that it
will silently transpose your array.</p>
</div>
</div>
<div class="section" id="reacting-to-user-input">
<h2>Reacting to user input<a class="headerlink" href="#reacting-to-user-input" title="Permalink to this headline">¶</a></h2>
<p>For input <a class="reference internal" href="eventlistener.html"><span class="doc">The Event Listener Module</span></a> is
used, which handles the corresponding pygame events. When the user presses a
key, a pygame.Event is generated and added to the event queue. The
<code class="xref py py-class docutils literal notranslate"><span class="pre">EventListener</span></code>’s <code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code> method will query all pending
events from the event-queue and process them according to handler-functions. It
has already three methods that should suffice for most needs:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for_n_keypresses()</span></code> will return if a specified key was</dt><dd><p>pressed n times.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for_keys()</span></code> will return if one of the given keys</dt><dd><p>was pressed and return the pressed key. It also supports a timeout; when the
timeout is reached without a user pressing one of the keys, <code class="docutils literal notranslate"><span class="pre">None</span></code> is
returned.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for_seconds()</span></code> will return after n seconds. Use this method</dt><dd><p>instead of <code class="docutils literal notranslate"><span class="pre">time.sleep()</span></code>, so events will be processed in the meantime.</p>
</dd>
</dl>
</li>
</ul>
<p>I recommend taking a look at the implementation of these 3 methods to see how
to use the <code class="xref py py-func docutils literal notranslate"><span class="pre">listen()</span></code>-method to implement your own handlers. The source
can be viewed from the <a class="reference internal" href="eventlistener.html"><span class="doc">module documentation page</span></a>. There,
you can also find in-depth explanations on how to use the EventListener class.</p>
<div class="section" id="getting-text-input">
<h3>Getting text input<a class="headerlink" href="#getting-text-input" title="Permalink to this headline">¶</a></h3>
<p>For text input <code class="xref py py-func docutils literal notranslate"><span class="pre">wait_for_unicode_char()</span></code> will return a string with the
last pressed key expressed as a single character, so pressing the a key, will
return an “a”, pressing shift + a will return “A” and pressing return will
return “r”. Therefore it is necessary to have a buffer. You can use
<code class="xref py py-func docutils literal notranslate"><span class="pre">process_char()</span></code> (from the misc module)
to update the buffer using the returned character.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyparadigm</span> <span class="kn">import</span> <span class="n">init</span><span class="p">,</span> <span class="n">EventListener</span><span class="p">,</span> <span class="n">compose</span><span class="p">,</span> <span class="n">display</span><span class="p">,</span> <span class="n">Text</span><span class="p">,</span>\
    <span class="n">Font</span><span class="p">,</span> <span class="n">process_char</span><span class="p">,</span> <span class="n">empty_surface</span><span class="p">,</span> <span class="n">Margin</span><span class="p">,</span> <span class="n">Surface</span>

<span class="n">init</span><span class="p">((</span><span class="mi">400</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="nb">buffer</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
<span class="n">el</span> <span class="o">=</span> <span class="n">EventListener</span><span class="p">()</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">display</span><span class="p">(</span><span class="n">compose</span><span class="p">(</span><span class="n">empty_surface</span><span class="p">(</span><span class="mh">0xFFFFFF</span><span class="p">))(</span>
        <span class="c1"># using a left top margin of 0 will put the resulting pygame.Surface</span>
        <span class="c1"># to the left top corner</span>
        <span class="n">Surface</span><span class="p">(</span><span class="n">Margin</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mi">0</span><span class="p">))(</span>
            <span class="n">Text</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">Font</span><span class="p">(</span><span class="s2">&quot;monospace&quot;</span><span class="p">),</span> <span class="n">align</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="p">)))</span>

    <span class="n">new_char</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">wait_for_unicode_char</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">new_char</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\x1b</span><span class="s2">&quot;</span><span class="p">:</span> <span class="c1"># Str representation of ESC</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">buffer</span> <span class="o">=</span> <span class="n">process_char</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">new_char</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-mouse-input">
<h3>Getting mouse input<a class="headerlink" href="#getting-mouse-input" title="Permalink to this headline">¶</a></h3>
<p>In this scenario it is easier to use an example. The following code will display
4 squares of random color:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">pyparadigm</span> <span class="kn">import</span> <span class="n">init</span><span class="p">,</span> <span class="n">EventListener</span><span class="p">,</span> <span class="n">compose</span><span class="p">,</span> <span class="n">display</span><span class="p">,</span>\
    <span class="n">empty_surface</span><span class="p">,</span> <span class="n">GridLayout</span><span class="p">,</span> <span class="n">Fill</span><span class="p">,</span> <span class="n">EventConsumerInfo</span>

<span class="kn">import</span> <span class="nn">pygame</span>

<span class="n">init</span><span class="p">((</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">))</span>
<span class="n">all_colors</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0xFFFFFF</span><span class="p">,</span> <span class="mh">0x000000</span><span class="p">,</span> <span class="mh">0xFF0000</span><span class="p">,</span> <span class="mh">0x00FF00</span><span class="p">,</span> <span class="mh">0x0000FF</span><span class="p">]</span>
<span class="n">active_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">all_colors</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">el</span> <span class="o">=</span> <span class="n">EventListener</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Fill</span><span class="p">(</span><span class="n">active_colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">display</span><span class="p">(</span><span class="n">compose</span><span class="p">(</span><span class="n">empty_surface</span><span class="p">(</span><span class="mh">0xFFFFFF</span><span class="p">),</span> <span class="n">GridLayout</span><span class="p">())(</span>
        <span class="p">[</span><span class="n">field</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">field</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">field</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
    <span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">wait_for_keys</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">K_ESCAPE</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">K_ESCAPE</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div>
</div>
<p>We will now introduce mouse support, to change the color of a square, if we
click on it. For that we install a <code class="xref py py-func docutils literal notranslate"><span class="pre">MouseProxy()</span></code> into the render tree.
A MouseProxy has a <code class="xref py py-func docutils literal notranslate"><span class="pre">_draw()</span></code> method that will be called by compose, but
it does not render anything, it only saves the assigned area, and then renders
its children.
A MouseProxy takes a handler function that takes 3 arguments, the event itself,
as well as an x and a y value, which are relative to the mouse area.</p>
<dl>
<dt>The event object iteself contains a few information:</dt><dd><ol class="arabic">
<li><dl class="simple">
<dt>type:</dt><dd><p>One of: pygame.MOUSEBUTTONUP, pygame.MOUSEBUTTONDOWN, or pygame.MOUSEMOTION.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>pos:</dt><dd><p>a 2-tuple with the window coordinates, x and y, of the click.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>pos_rel:</dt><dd><p>only for MOUSEMOTION, contains the differences for x and y since the last
MOUSEMOTION event.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>buttons:</dt><dd><p>only for MOUSEMOTION, contains a 3-tuple each value is 0 or 1, representing
whether the correspoding button is pressed (1) or not (0). The order is
(LEFT, MIDDLE, RIGHT)</p>
</dd>
</dl>
</li>
<li><dl>
<dt>button:</dt><dd><p>only for MOUSEBUTTONUP and MOUSEBUTTONDOWN: contains the keycode of the
pressed button. Since pygame did not define constants for them, they are
defined in the eventlistener module. The possible values are:</p>
<blockquote>
<div><ul class="simple">
<li><p>MOUSE_LEFT</p></li>
<li><p>MOUSE_MIDDLE</p></li>
<li><p>MOUSE_RIGHT</p></li>
<li><p>MOUSE_SCROL_FW (forwards)</p></li>
<li><p>MOUSE_SCROL_BW (backwards)</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">MouseProxy</span></code> class has a method listener, which could be used in
conjunction with EventListener.listen().</p>
<p>There is a shortcut though: <code class="xref py py-func docutils literal notranslate"><span class="pre">EventListener.mouse_area()</span></code> it creates
MouseProxy, stores it internally, and returns it. Every stored proxy is assigned
a group (0 by default), and only the mouse proxies from within the active group
are used as permanent handler. To prevent recreation of existing proxies during
repeated calls every proxy is assigned an id, by default the memory address of
their handlers are used.
There is a function <code class="xref py py-func docutils literal notranslate"><span class="pre">EventListener.group()</span></code> which sets the current group,
so you could use something like <cite>el.group(2).wait_for_keys(…)</cite> to specify
which group of mouse proxies should be used explicitly. To disable proxies
simply use the id of a non existing group.</p>
<p>A version of the upper example which changes the color of a square randomly, if
you click on it is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">pyparadigm</span> <span class="kn">import</span> <span class="n">init</span><span class="p">,</span> <span class="n">EventListener</span><span class="p">,</span> <span class="n">compose</span><span class="p">,</span> <span class="n">display</span><span class="p">,</span>\
    <span class="n">empty_surface</span><span class="p">,</span> <span class="n">GridLayout</span><span class="p">,</span> <span class="n">Fill</span><span class="p">,</span> <span class="n">EventConsumerInfo</span><span class="p">,</span> <span class="n">MOUSE_LEFT</span>

<span class="kn">import</span> <span class="nn">pygame</span>

<span class="n">init</span><span class="p">((</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">))</span>
<span class="n">all_colors</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0xFFFFFF</span><span class="p">,</span> <span class="mh">0x000000</span><span class="p">,</span> <span class="mh">0xFF0000</span><span class="p">,</span> <span class="mh">0x00FF00</span><span class="p">,</span> <span class="mh">0x0000FF</span><span class="p">]</span>
<span class="n">active_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">all_colors</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">el</span> <span class="o">=</span> <span class="n">EventListener</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">make_id_returner</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">i</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">MOUSEBUTTONDOWN</span>
                                <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">button</span> <span class="o">==</span> <span class="n">MOUSE_LEFT</span><span class="p">)</span>\
        <span class="k">else</span> <span class="n">EventConsumerInfo</span><span class="o">.</span><span class="n">DONT_CARE</span>

<span class="k">def</span> <span class="nf">field</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">el</span><span class="o">.</span><span class="n">mouse_area</span><span class="p">(</span><span class="n">make_id_returner</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">Fill</span><span class="p">(</span><span class="n">active_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">display</span><span class="p">(</span><span class="n">compose</span><span class="p">(</span><span class="n">empty_surface</span><span class="p">(</span><span class="mh">0xFFFFFF</span><span class="p">),</span> <span class="n">GridLayout</span><span class="p">())(</span>
        <span class="p">[</span><span class="n">field</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">field</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">field</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">field</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
    <span class="p">))</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">wait_for_keys</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">K_ESCAPE</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">K_ESCAPE</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">active_colors</span><span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">all_colors</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="the-misc-module">
<h2>The Misc-Module<a class="headerlink" href="#the-misc-module" title="Permalink to this headline">¶</a></h2>
<p>The Misc-Module contains everything that was handy enough to be part of
PyParadigm, but was not big enough for its own module.
It contains the following functions:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">init()</span></code> needs to be called before any other call to a member of</dt><dd><p>PyParadgim and creates the pygame window in which the contents will be displayed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">display()</span></code> can be used to conveniently display a pygame surface,</dt><dd><p>which has the size of the pygame window.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">slide_show()</span></code> takes a list of pygame.Surfaces, which are supposed</dt><dd><p>to have the same size as the display window, and a handler function. When
the handler function returns, the next slide is shown. Handy to display
multi-page text.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">empty_surface()</span></code> creates a new pygame.Surface of the given size</dt><dd><p>(or of the size of the pygame window, if no size was specified) and
automatically fills it with a given background color.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">process_char()</span></code> returns a new version of a given buffer, modified</dt><dd><p>based on a string containing a unicode character.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="next-step">
<h2>Next Step<a class="headerlink" href="#next-step" title="Permalink to this headline">¶</a></h2>
<p>The next step now would be to take a look the <a class="reference internal" href="examples.html"><span class="doc">the examples</span></a> to
see how to apply what you just learned.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">PyParadigm</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">A tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-a-window">Creating a Window</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-surfaces">Creating Surfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reacting-to-user-input">Reacting to user input</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-misc-module">The Misc-Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#next-step">Next Step</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="surfacecomposition.html">The Surface Composition Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="eventlistener.html">The Event Listener Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">The Misc-Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="extras.html">Extras</a></li>
<li class="toctree-l1"><a class="reference internal" href="dialogs.html">The Dialogs-Module</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to PyParadigm</a></li>
      <li>Next: <a href="examples.html" title="next chapter">Examples</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Felix G. Knorr.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/tutorial.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>